
#ifdef GL_ES
precision highp float;
#endif
varying vec3 pos;varying vec3 norm;varying vec2 tex;varying vec2 screenCoord;uniform vec4 uLightColorFar;uniform vec4 uLightPosRadius;uniform vec4 uMaterialColor;uniform vec4 uScreenSizeNearFar;uniform samplerCube shadowMap;uniform sampler2D depthBuffer;uniform mat4 uPVMatrix;vec3 a;vec3 b;float c(vec3 d){vec3 e=textureCube(shadowMap,d).xyz;float f=dot(e,vec3(1.0,1.0/256.0,1.0/(256.0*256.0)));return f*2.0-0.99;}float g(vec3 d){d.x=-d.x;float h=max(max(abs(d.x),abs(d.y)),abs(d.z));float i=uLightPosRadius.w*0.9;float j=uLightColorFar.w;float k=j-i;float l=(j+i)/k;float m=(2.0*j*i)/k;float n=min((h*l-m)/h,1.0);float f=c(d);if(n>=f) return 0.0;return 1.0;}
#define M_PI 3.14159265

#define N_CIRCLE_PCSS 7

#define N_RADIUS_PCSS 4

#define N_CIRCLE_SSAO 4

#define N_RADIUS_SSAO 3
float o(vec2 p){return fract(sin(dot(p,vec2(78.611,61.178)))*20163.001);}float q(vec2 p){return fract(sin(dot(p,vec2(61.178,78.611)))*20160.102);}float r(float s){float t=uLightPosRadius.w*0.9;float u=uLightColorFar.w;return (2.0*t)/((u+t)-((s+1.0)/2.0)*(u-t));}float v(vec3 d,vec3 w){d.x=-d.x;float h=max(max(abs(d.x),abs(d.y)),abs(d.z));float t=uLightPosRadius.w*0.9;float u=uLightColorFar.w;float k=u-t;float l=(u+t)/k;float m=(2.0*u*t)/k;float n=min((h*l-m)/h,1.0);float f=c(d);float x=0.0;float y=0.0;float j=0.0;if(f!=1.0&&f<n){j++;x++;y+=f;}float z=(o(gl_FragCoord.xy)*2.)-1.;float A=uLightPosRadius.w*(float(N_RADIUS_PCSS)-1.0+q(gl_FragCoord.xy))/float(N_RADIUS_PCSS);for(int B=0;B<N_CIRCLE_PCSS;B++){float C=(float(B)+z)*M_PI*(2./float(N_CIRCLE_PCSS));vec2 D=vec2(sin(C),cos(C));for(int E=N_RADIUS_PCSS;E>0;E--){float F=A*float(E)/float(N_RADIUS_PCSS);vec3 G=d+b*(D[0]*F)+a*(D[1]*F);h=max(max(abs(G.x),abs(G.y)),abs(G.z));float H=(h*l-m)/h;f=c(G);if(f!=1.0&&f<H){x++;y+=f;}}}if(x==0.0) return 1.0;y/=x;A*=uLightPosRadius.w*(r(n)-r(y))/r(y);for(int B=0;B<N_CIRCLE_PCSS;B++){float C=(float(B)+z)*M_PI*(2./float(N_CIRCLE_PCSS));vec2 D=vec2(sin(C),cos(C));for(int E=N_RADIUS_PCSS;E>0;E--){float F=A*float(E)/float(N_RADIUS_PCSS);vec3 G=d+b*(D[0]*F)+a*(D[1]*F);h=max(max(abs(G.x),abs(G.y)),abs(G.z));float H=(h*l-m)/h;f=c(G);if(f!=1.0&&f<H){j++;}}}return 1.0-(j/(float(N_CIRCLE_PCSS)*float(N_RADIUS_PCSS)+1.0));}float I(in vec3 J,in vec3 w){vec3 K=uLightPosRadius.xyz-J.xyz;float L=length(K);vec2 z=vec2(L,uLightPosRadius.w);z=normalize(z);float M=dot(w.xyz,K.xyz)/L;M+=(1.0-z.x);M=max(M,0.0);return M*v(K,w);}float N(float s){float t=uScreenSizeNearFar.z;float u=uScreenSizeNearFar.w;return (2.0*t)/((u+t)-((s+1.0)/2.0)*(u-t));}float O(float s){float t=uScreenSizeNearFar.z;float u=uScreenSizeNearFar.w;return t+N(s)*(u-t);}
#define OCCL_RADIUS 0.01
float P(vec2 Q){float R=(q(gl_FragCoord.xy)*2.)-1.;float S=N(texture2D(depthBuffer,Q).x);float T=1.0;for(int B=0;B<N_CIRCLE_SSAO;B++){float C=(float(B)+R)*M_PI*(2./float(N_CIRCLE_SSAO));vec2 D=vec2(sin(C),cos(C));for(int E=N_RADIUS_SSAO;E>0;E--){float F=OCCL_RADIUS*float(E)/float(N_RADIUS_SSAO);vec2 U=Q+vec2(D[0],D[1])*F;float V=N(texture2D(depthBuffer,U).x);float W=S-V;if((W>0.0)&&(W<OCCL_RADIUS)){T-=min(W,OCCL_RADIUS)/(OCCL_RADIUS*float(N_CIRCLE_SSAO)*float(N_RADIUS_SSAO));}}}return T;}float X(vec2 Q){float R=(q(gl_FragCoord.xy)*2.)-1.;float S=O(texture2D(depthBuffer,Q).x);float T=1.0;for(int B=0;B<N_CIRCLE_SSAO;B++){float C=(float(B)+R)*M_PI*(2./float(N_CIRCLE_SSAO));vec2 D=vec2(sin(C),cos(C));for(int E=N_RADIUS_SSAO;E>0;E--){float F=OCCL_RADIUS*float(E)/float(N_RADIUS_SSAO);vec3 U=(uPVMatrix*vec4(pos+b*(D[0]*F)+a*(D[1]*F),1)).xyz;float V=N(texture2D(depthBuffer,(U.xy+1.0)/2.0).x);float W=U.z-V;if((W>0.0)&&(W<OCCL_RADIUS)){T-=min(W,OCCL_RADIUS)/(OCCL_RADIUS*float(N_CIRCLE_SSAO)*float(N_RADIUS_SSAO));}}}return T;}void main(){a=abs(norm.y)>0.9?vec3(0,0,1):vec3(0,1,0);b=normalize(cross(a,norm));a=normalize(cross(b,norm));vec3 Y=uLightColorFar.xyz*I(pos,norm);vec2 Q=gl_FragCoord.xy/uScreenSizeNearFar.xy;vec3 Z=vec3(0.5)*P(Q);gl_FragColor.xyz=uMaterialColor.xyz*(Y+Z);gl_FragColor.w=uMaterialColor.w;}